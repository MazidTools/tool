<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AES & Protobuf Decoder (Blackbox Style)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    
    <style>
        :root {
            --bg-color: #1e1e2e;
            --card-bg: #2b2b40;
            --text-color: #cdd6f4;
            --accent-color: #89b4fa;
            --success-color: #a6e3a1;
            --error-color: #f38ba8;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            min-height: 100vh;
        }

        .container {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            width: 100%;
            max-width: 800px;
        }

        h2 {
            margin-top: 0;
            color: var(--accent-color);
            text-align: center;
        }

        .config-info {
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.9em;
            margin-bottom: 20px;
            border-left: 3px solid var(--accent-color);
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }

        select, textarea {
            width: 100%;
            padding: 10px;
            background-color: #181825;
            border: 1px solid #45475a;
            color: white;
            border-radius: 6px;
            font-family: monospace;
            box-sizing: border-box;
        }

        textarea {
            height: 100px;
            resize: vertical;
        }

        button {
            background-color: var(--accent-color);
            color: #111;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            transition: background 0.2s;
        }

        button:hover {
            background-color: #b4befe;
        }

        .output-area {
            margin-top: 20px;
            background-color: #11111b;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            border: 1px solid #45475a;
        }

        pre {
            margin: 0;
            color: #a6adc8;
        }

        .status {
            margin-top: 10px;
            font-weight: bold;
        }
        .status.success { color: var(--success-color); }
        .status.error { color: var(--error-color); }

        .hidden { display: none; }
    </style>
</head>
<body>

<div class="container">
    <h2>AES + Protobuf Decoder</h2>

    <div class="config-info">
        <strong>By Mazid Gamer</strong><br>
    </div>

    <div class="control-group">
        <label>Select Mode:</label>
        <select id="decodeMode">
            <option value="1">1. AES Decrypt + Protobuf Decode</option>
            <option value="2">2. Only Protobuf Decode (Raw Hex)</option>
        </select>
    </div>

    <div class="control-group">
        <label>Input Hex String:</label>
        <textarea id="inputData" placeholder="Paste your hex string here..."></textarea>
    </div>

    <button onclick="processData()">Decode</button>

    <div id="statusMsg" class="status"></div>

    <div id="rawOutputContainer" class="hidden">
        <label style="margin-top: 15px">Decrypted Bytes (Hex):</label>
        <div class="output-area">
            <pre id="rawOutput"></pre>
        </div>
    </div>

    <label style="margin-top: 15px">Protobuf JSON Output:</label>
    <div class="output-area">
        <pre id="jsonOutput">Waiting for input...</pre>
    </div>
</div>

<script>
    // --- Configuration ---
    const CONFIG = {
        keyStr: "Yg&tc%DEuh6%Zc^8",
        ivStr:  "6oyZDr22E3ychjM%"
    };

    function processData() {
        const mode = document.getElementById('decodeMode').value;
        let hexInput = document.getElementById('inputData').value.trim();
        const statusEl = document.getElementById('statusMsg');
        const rawOutputEl = document.getElementById('rawOutput');
        const jsonOutputEl = document.getElementById('jsonOutput');
        const rawContainer = document.getElementById('rawOutputContainer');

        // Cleanup hex input (remove spaces/newlines)
        hexInput = hexInput.replace(/\s+/g, '');

        if (!hexInput) {
            statusEl.textContent = "Error: Input is empty.";
            statusEl.className = "status error";
            return;
        }

        try {
            let decryptedBytes;

            // 1. Decryption Phase
            if (mode === '1') {
                statusEl.textContent = "Decrypting AES...";
                statusEl.className = "status";
                
                // Convert Strings to WordArrays
                const key = CryptoJS.enc.Utf8.parse(CONFIG.keyStr);
                const iv = CryptoJS.enc.Utf8.parse(CONFIG.ivStr);
                
                // Parse Input
                const cipherParams = CryptoJS.lib.CipherParams.create({
                    ciphertext: CryptoJS.enc.Hex.parse(hexInput)
                });

                // Perform Decryption
                const decrypted = CryptoJS.AES.decrypt(
                    cipherParams, 
                    key, 
                    { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }
                );

                // Check if decryption actually worked (if empty, padding likely failed)
                if (decrypted.sigBytes < 0) {
                    throw new Error("Decryption failed (Padding Error or Wrong Key/IV).");
                }

                // Convert WordArray to Uint8Array for Protobuf
                decryptedBytes = wordArrayToUint8Array(decrypted);
                
                // Show Raw Hex
                rawContainer.classList.remove('hidden');
                rawOutputEl.textContent = uint8ArrayToHex(decryptedBytes);

            } else {
                // Direct Protobuf Mode
                rawContainer.classList.add('hidden');
                try {
                    decryptedBytes = hexToUint8Array(hexInput);
                } catch(e) {
                    throw new Error("Invalid Hex String provided.");
                }
            }

            // 2. Protobuf Decoding Phase
            statusEl.textContent = "Decoding Protobuf...";
            
            // "Blackbox" decoding
            const protoObj = decodeProto(decryptedBytes);
            
            // Output
            jsonOutputEl.textContent = JSON.stringify(protoObj, (key, value) => {
                // Custom Replacer to handle BigInt if needed, or buffers
                if (typeof value === 'bigint') return value.toString();
                return value;
            }, 4);

            statusEl.textContent = "Success!";
            statusEl.className = "status success";

        } catch (e) {
            console.error(e);
            statusEl.textContent = "Error: " + e.message;
            statusEl.className = "status error";
            jsonOutputEl.textContent = "Processing Failed.";
        }
    }

    // --- Helpers: Type Conversion ---

    function wordArrayToUint8Array(wordArray) {
        const words = wordArray.words;
        const sigBytes = wordArray.sigBytes;
        const u8 = new Uint8Array(sigBytes);
        for (let i = 0; i < sigBytes; i++) {
            u8[i] = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
        }
        return u8;
    }

    function uint8ArrayToHex(u8) {
        return Array.from(u8).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function hexToUint8Array(hexString) {
        if (hexString.length % 2 !== 0) throw new Error("Invalid hex length");
        const bytes = new Uint8Array(hexString.length / 2);
        for (let i = 0; i < bytes.length; i++) {
            bytes[i] = parseInt(hexString.substr(i * 2, 2), 16);
        }
        return bytes;
    }

    // --- Core: Lightweight Schema-less Protobuf Decoder ---
    // mimics blackboxprotobuf basic behavior (recursive)
    
    function decodeProto(buffer) {
        let offset = 0;
        const result = {};

        while (offset < buffer.length) {
            // Read Tag (Varint)
            const { value: tag, length: tagLen } = readVarint(buffer, offset);
            offset += tagLen;

            const fieldNumber = tag >>> 3;
            const wireType = tag & 7;
            let value;

            // Decide how to read based on Wire Type
            if (wireType === 0) { // Varint
                const v = readVarint(buffer, offset);
                value = v.value; // Keeps it as Number (or BigInt if needed logic extended)
                offset += v.length;
            } 
            else if (wireType === 1) { // 64-bit (fixed)
                // Reading 8 bytes as Hex string for simplicity
                value = "0x" + uint8ArrayToHex(buffer.slice(offset, offset + 8));
                offset += 8;
            } 
            else if (wireType === 2) { // Length Delimited (String, Bytes, Nested Message)
                const len = readVarint(buffer, offset);
                offset += len.length;
                const bytes = buffer.slice(offset, offset + len.value);
                offset += len.value;

                // Heuristic: Try to decode as String, if fails check if Nested Proto, else Hex
                if (isPrintableString(bytes)) {
                    value = new TextDecoder().decode(bytes);
                } else {
                    // Try to decode recursively as a message
                    try {
                        // Simple check: recursive decode shouldn't leave leftover bytes usually
                        // and shouldn't be empty if bytes weren't empty
                        const nested = decodeProto(bytes);
                        // If result is empty object but bytes weren't empty, it might just be binary
                        if (Object.keys(nested).length === 0 && bytes.length > 0) {
                             value = "0x" + uint8ArrayToHex(bytes); // Fallback
                        } else {
                            value = nested;
                        }
                    } catch (e) {
                        value = "0x" + uint8ArrayToHex(bytes);
                    }
                }
            } 
            else if (wireType === 5) { // 32-bit (fixed)
                value = "0x" + uint8ArrayToHex(buffer.slice(offset, offset + 4));
                offset += 4;
            } 
            else {
                // Unknown wire type, abort parsing this branch
                throw new Error("Unknown WireType: " + wireType);
            }

            // Store in result (handle repeated fields by turning into array)
            if (result[fieldNumber]) {
                if (!Array.isArray(result[fieldNumber])) {
                    result[fieldNumber] = [result[fieldNumber]];
                }
                result[fieldNumber].push(value);
            } else {
                result[fieldNumber] = value;
            }
        }
        return result;
    }

    // Helper: Read Varint (Base 128)
    function readVarint(buffer, offset) {
        let result = 0;
        let shift = 0;
        let length = 0;
        
        while (true) {
            if (offset + length >= buffer.length) throw new Error("Varint out of bounds");
            let byte = buffer[offset + length];
            length++;
            
            // Javascript bitwise operations are 32-bit. 
            // For simple parsing we use standard math for safety up to 53 bits (SAFE_INTEGER)
            result += (byte & 0x7F) * Math.pow(2, shift);
            shift += 7;
            
            if ((byte & 0x80) === 0) break;
        }
        return { value: result, length: length };
    }

    // Helper: Check if bytes look like UTF-8 Text
    function isPrintableString(bytes) {
        if (bytes.length === 0) return true;
        for (let i = 0; i < bytes.length; i++) {
            const b = bytes[i];
            // Allow printable ASCII and common UTF-8 start bytes
            // This is a very basic heuristic.
            if (b < 0x09 || (b > 0x0D && b < 0x20)) return false; 
        }
        return true;
    }

</script>

</body>
</html>
